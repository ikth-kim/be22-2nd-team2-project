<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org" xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
    layout:decorate="~{layout}">

<head>
    <title>Next Page - ì†Œì„¤ ìƒì„¸</title>
    <style>
        .typing-dot {
            display: inline-block;
            width: 4px;
            height: 4px;
            background-color: var(--primary-color);
            border-radius: 50%;
            margin-right: 2px;
            animation: typing-blink 1s infinite;
            vertical-align: middle;
        }

        @keyframes typing-blink {

            0%,
            100% {
                opacity: 0.3;
                transform: scale(0.8);
            }

            50% {
                opacity: 1;
                transform: scale(1.2);
            }
        }
    </style>
</head>

<body>

    <div layout:fragment="content" id="app">
        <!-- Loading State -->
        <div v-if="loading" class="text-center" style="padding: 50px;">
            <h2>Loading...</h2>
        </div>

        <div v-else>
            <!-- Title Section with Edit -->
            <div id="book-header" class="text-center mb-4 fade-in">
                <div v-if="!isEditingTitle"
                    style="display: flex; justify-content: center; align-items: center; gap: 10px;">
                    <h1 style="margin-bottom: 10px;">{{ book.title }}</h1>
                    <button v-if="canEditBook" @click="startEditTitle" class="btn btn-ghost btn-sm"
                        title="ì œëª© ìˆ˜ì •">âœï¸</button>
                    <button v-if="canEditBook" @click="deleteBook" class="btn btn-ghost btn-sm" title="ì†Œì„¤ ì‚­ì œ"
                        style="color: #ff6b6b;">ğŸ—‘ï¸</button>
                </div>
                <div v-else
                    style="display: flex; justify-content: center; align-items: center; gap: 10px; margin-bottom: 10px;">
                    <input v-model="editTitleContent" class="form-control"
                        style="font-size: 1.5rem; width: auto; text-align: center;">
                    <button @click="saveTitle" class="btn btn-primary btn-sm">ì €ì¥</button>
                    <button @click="cancelEditTitle" class="btn btn-outline btn-sm">ì·¨ì†Œ</button>
                </div>

                <p style="color: var(--text-muted);">
                    <span>{{ getCategoryName(book.categoryId) }}</span> |
                    <span>{{ book.status }}</span> |
                    ì‘ê°€ <span>{{ book.sentences ? (new Set(book.sentences.map(s => s.writerId)).size) : 1 }}</span>ëª…
                </p>
                <div style="text-align: center; margin-top: 15px;">
                    <button class="btn" :class="book.myVote === 'LIKE' ? 'btn-primary' : 'btn-outline'"
                        @click="voteBook('LIKE')">
                        ğŸ‘ ê°œì¶” <span>{{ book.likeCount || 0 }}</span>
                    </button>
                    <button class="btn" style="margin-left: 5px;"
                        :class="book.myVote === 'DISLIKE' ? 'btn-primary' : 'btn-outline'" @click="voteBook('DISLIKE')">
                        ğŸ‘ ë¹„ì¶” <span>{{ book.dislikeCount || 0 }}</span>
                    </button>
                    <a v-if="book.status === 'COMPLETED'" :href="'/books/' + bookId + '/viewer'" class="btn btn-primary"
                        style="margin-left: 10px;">ğŸ“– ì±…ìœ¼ë¡œ ì½ê¸°</a>
                    <button v-if="book.status === 'WRITING' && isWriter" @click="completeBook" class="btn btn-outline"
                        style="margin-left: 10px; border-color: var(--accent-color); color: var(--accent-color);">
                        âœ¨ ì™„ê²° ì§“ê¸°
                    </button>
                </div>
            </div>

            <div class="container" style="max-width: 800px;">
                <!-- Sentence List -->
                <div id="sentence-list" style="margin-bottom: 40px;">
                    <div v-for="sent in sortedSentences" :key="sent.sentenceId" class="card"
                        style="padding: 20px; margin-bottom: 15px; border-left: 4px solid var(--primary-color);">

                        <div v-if="editingSentenceId !== sent.sentenceId">
                            <p
                                style="font-size: 1.1rem; line-height: 1.8; margin-bottom: 15px; color: var(--text-color);">
                                {{ sent.content }}
                                <button v-if="canEditSentence(sent)" @click="startEditSentence(sent)"
                                    class="btn btn-ghost btn-sm" title="ë¬¸ì¥ ìˆ˜ì •"
                                    style="margin-left: 5px; opacity: 0.5;">âœï¸</button>
                                <button v-if="canEditSentence(sent) && editingSentenceId !== sent.sentenceId"
                                    @click="deleteSentence(sent)" class="btn btn-ghost btn-sm" title="ë¬¸ì¥ ì‚­ì œ"
                                    style="margin-left: 5px; opacity: 0.5; color: #ff6b6b;">ğŸ—‘ï¸</button>
                            </p>
                        </div>
                        <div v-else style="margin-bottom: 15px;">
                            <textarea v-model="editSentenceContent" class="form-control" rows="3"></textarea>
                            <div style="margin-top: 5px; text-align: right;">
                                <button @click="saveSentence(sent)" class="btn btn-primary btn-sm">ì €ì¥</button>
                                <button @click="cancelEditSentence" class="btn btn-outline btn-sm">ì·¨ì†Œ</button>
                            </div>
                        </div>

                        <div
                            style="font-size: 0.85rem; color: var(--text-muted); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px;">
                            <span style="font-weight: 600;">No.{{ sent.sequenceNo }} by {{ sent.writerNicknm }}</span>
                            <div class="vote-buttons">
                                <button class="vote-btn" :class="{'active-like': sent.myVote === 'LIKE'}"
                                    @click="voteSentence(sent, 'LIKE')">
                                    ğŸ‘ <span>{{ sent.likeCount || 0 }}</span>
                                </button>
                                <button class="vote-btn" :class="{'active-dislike': sent.myVote === 'DISLIKE'}"
                                    @click="voteSentence(sent, 'DISLIKE')">
                                    ğŸ‘ <span>{{ sent.dislikeCount || 0 }}</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Writing Area -->
                <div v-if="book.status !== 'COMPLETED'" id="writing-area" class="card fade-in" style="padding: 20px;">
                    <div
                        style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                        <h3 style="margin: 0; font-size: 1.1rem; font-weight: 600;">ë‹¤ìŒ ë¬¸ì¥ ì´ì–´ì“°ê¸°</h3>
                        <!-- Typing Indicator -->
                        <div v-show="activeTypers.length > 0"
                            style="font-size: 0.8rem; color: var(--primary-color); display: flex; align-items: center; gap: 4px;">
                            <span style="display: flex; gap: 2px;">
                                <span class="typing-dot" style="animation-delay: 0s;"></span>
                                <span class="typing-dot" style="animation-delay: 0.2s;"></span>
                                <span class="typing-dot" style="animation-delay: 0.4s;"></span>
                            </span>
                            <span style="font-weight: 600; margin-left: 4px;">{{ activeTypers.join(', ') }}</span>ë‹˜ì´ ì…ë ¥
                            ì¤‘...
                        </div>
                    </div>

                    <!-- Guest Only -->
                    <div v-if="!isLoggedIn" class="guest-only"
                        style="text-align: center; padding: 25px 15px; background: rgba(0,0,0,0.02); border-radius: 12px; border: 1px dashed rgba(0,0,0,0.1);">
                        <p style="color: var(--text-muted); margin-bottom: 15px; font-size: 0.9rem;">
                            ì´ì•¼ê¸°ì— ì°¸ì—¬í•˜ë ¤ë©´ ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.
                        </p>
                        <button onclick="openModal('login-modal')" class="btn btn-primary"
                            style="padding: 8px 20px; font-size: 0.85rem; border-radius: 20px;">
                            ë¡œê·¸ì¸í•˜ê³  ì´ì–´ì“°ê¸°
                        </button>
                    </div>

                    <!-- User Only -->
                    <div v-else class="user-only" style="display: flex; flex-direction: column; gap: 10px;">
                        <textarea v-model="newSentence" @input="handleInput" @blur="handleBlur" class="form-control"
                            rows="3" :placeholder="inputPlaceholder"
                            style="border-radius: 12px; font-size: 1rem; resize: none; min-height: 120px; padding: 15px;"
                            :disabled="isInputDisabled"></textarea>
                        <div style="display: flex; justify-content: flex-end;">
                            <button class="btn btn-primary" @click="submitSentence" :disabled="isInputDisabled"
                                style="padding: 12px 30px; font-size: 1rem; border-radius: 25px; font-weight: 600; box-shadow: 0 4px 6px rgba(var(--primary-rgb), 0.2);">ë¬¸ì¥
                                ë“±ë¡</button>
                        </div>
                    </div>
                </div>
                <div v-else class="text-center" style="margin-top: 20px;">
                    <span class="badge badge-completed">ì™„ê²°ë¨</span>
                </div>

                <!-- Comments Area -->
                <div class="card fade-in"
                    style="margin-top: 40px; padding: 20px; background: linear-gradient(135deg, #F0F9FF 0%, #E0F2FE 100%); border: 2px solid #BAE6FD;">
                    <div
                        style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
                        <h3 style="margin: 0; font-size: 1.1rem; font-weight: 600;">ê°ìƒí‰</h3>
                        <div v-show="activeCommentTypers.length > 0"
                            style="font-size: 0.75rem; color: var(--secondary-color);">
                            ğŸ’¬ <span style="font-weight: 600;">{{ activeCommentTypers.join(', ') }}</span>ë‹˜ì´ ì‘ì„± ì¤‘...
                        </div>
                    </div>

                    <div v-if="!isLoggedIn" class="guest-only"
                        style="text-align: center; padding: 20px; background: rgba(0,0,0,0.02); border-radius: 12px; margin-bottom: 20px;">
                        <button onclick="openModal('login-modal')" class="btn btn-outline"
                            style="padding: 6px 20px; font-size: 0.8rem; border-radius: 20px;">
                            ë¡œê·¸ì¸í•˜ê³  ê°ìƒí‰ ë‚¨ê¸°ê¸°
                        </button>
                    </div>

                    <div v-else class="user-only">
                        <div style="display: flex; flex-direction: column; gap: 10px; width: 100%;">
                            <textarea v-model="newComment" @input="handleCommentInput" @blur="handleCommentBlur"
                                class="form-control" rows="3" placeholder="ì´ ì†Œì„¤ì— ëŒ€í•œ ê°ìƒí‰ì„ ë‚¨ê²¨ì£¼ì„¸ìš”..."
                                style="border-radius: 15px; font-size: 0.95rem; padding: 15px; resize: none; min-height: 100px;"></textarea>
                            <div style="display: flex; justify-content: flex-end;">
                                <button class="btn btn-primary" @click="submitComment"
                                    style="padding: 10px 30px; font-size: 0.9rem; border-radius: 25px; box-shadow: 0 4px 6px rgba(var(--primary-rgb), 0.2);">ë“±ë¡</button>
                            </div>
                        </div>
                    </div>

                    <div id="comment-list">
                        <comment-node v-for="comment in comments" :key="comment.commentId" :comment="comment"
                            :is-logged-in="isLoggedIn" :current-user-id="currentUserId" :user-role="currentUserRole"
                            @reply="submitReply" @edit="editComment" @delete="deleteComment"></comment-node>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <th:block layout:fragment="script">
        <script>
            const { createApp } = Vue;

            const CommentNode = {
                name: 'CommentNode',
                props: ['comment', 'isLoggedIn', 'currentUserId', 'userRole'],
                data() {
                    return {
                        showReplyForm: false,
                        replyContent: '',
                        isEditing: false,
                        editContent: ''
                    }
                },
                computed: {
                    canEdit() {
                        // Check if writer or admin.
                        // Need currentUserId and userRole from prop.
                        // Comment update API needs impl in backend? Yes ReactionController has modifyComment.
                        if (!this.isLoggedIn) return false;
                        const isAdmin = this.userRole === 'ADMIN' || this.userRole === 'ROLE_ADMIN';
                        // Since we don't have writerId in CommentDto directly here (only nicknm), we might need to rely on backend.
                        // Wait, CommentDto usually has writerId? Let's assume yes or rely on loose check if nickname matches (not secure but UI hint).
                        // Actually CommentQueryController returns CommentDto. Let's check CommentDto.java.
                        // Assuming CommentDto has writerId.
                        return (this.currentUserId && this.comment.writerId === this.currentUserId) || isAdmin;
                    }
                },
                template: `
                <div class="comment-node card-subtle" style="padding: 15px; margin-bottom: 10px; border-radius: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                        <div>
                            <span style="font-weight: 700; font-size: 0.95rem; color: var(--primary-color);">{{ comment.writerNicknm }}</span>
                            <span style="font-size: 0.8rem; color: var(--text-muted); margin-left: 8px;">{{ new Date(comment.createdAt).toLocaleString() }}</span>
                        </div>
                         <div style="display: flex; gap: 5px;">
                            <button v-if="!isEditing && canEdit" class="btn btn-ghost btn-sm" @click="startEdit" style="padding: 2px 5px; font-size: 0.8rem;">âœï¸</button>
                            <button v-if="canEdit" class="btn btn-ghost btn-sm" @click="deleteSelf" style="padding: 2px 5px; font-size: 0.8rem; color: red;">ğŸ—‘ï¸</button>
                            <button class="btn btn-ghost btn-sm" @click="toggleReply" style="padding: 2px 8px; font-size: 0.8rem;">ğŸ’¬ ë‹µê¸€</button>
                         </div>
                    </div>
                    
                    <div v-if="!isEditing" class="comment-content" style="font-size: 1rem; color: var(--text-color); line-height: 1.5; margin-bottom: 5px;">{{ comment.content }}</div>
                    <div v-else style="margin-bottom: 10px;">
                        <textarea v-model="editContent" class="form-control" rows="2"></textarea>
                         <div style="margin-top: 5px; text-align: right;">
                             <button @click="saveEdit" class="btn btn-primary btn-sm" style="padding: 2px 10px;">ì €ì¥</button>
                             <button @click="cancelEdit" class="btn btn-outline btn-sm" style="padding: 2px 10px;">ì·¨ì†Œ</button>
                         </div>
                    </div>
                    
                    <div v-if="showReplyForm" style="margin-top: 15px; align-items: flex-start; gap: 10px; animation: fadeIn 0.3s ease; display: flex;">
                        <textarea v-model="replyContent" class="form-control" rows="2" style="font-size: 0.9rem; border-radius: 12px; resize: none; padding: 10px;" placeholder="ë‹µê¸€ì„ ë‚¨ê²¨ì£¼ì„¸ìš”..."></textarea>
                        <button class="btn btn-primary" style="padding: 0 20px; font-size: 0.85rem; border-radius: 20px; height: 50px; white-space: nowrap;" @click="submitReply">ë“±ë¡</button>
                    </div>

                    <div v-if="comment.children && comment.children.length > 0" class="comment-children" style="margin-left: 20px; border-left: 2px solid rgba(255,255,255,0.1); padding-left: 15px; margin-top: 15px;">
                        <comment-node v-for="child in comment.children" :key="child.commentId" 
                            :comment="child" :is-logged-in="isLoggedIn" :current-user-id="currentUserId" :user-role="userRole"
                            @reply="$emit('reply', $event)" @edit="$emit('edit', $event)" @delete="$emit('delete', $event)"></comment-node>
                    </div>
                </div>
                `,
                methods: {
                    toggleReply() { this.showReplyForm = !this.showReplyForm; },
                    submitReply() {
                        if (!this.replyContent) return;
                        const replyLink = this.comment._links && this.comment._links.reply ? this.comment._links.reply.href : null;
                        this.$emit('reply', { content: this.replyContent, parentId: this.comment.commentId, link: replyLink, callback: () => { this.replyContent = ''; this.showReplyForm = false; } });
                    },
                    startEdit() { this.editContent = this.comment.content; this.isEditing = true; },
                    cancelEdit() { this.isEditing = false; },
                    saveEdit() {
                        this.$emit('edit', { commentId: this.comment.commentId, content: this.editContent, callback: () => { this.isEditing = false; } });
                    },
                    deleteSelf() {
                        openConfirmModal('ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?', () => {
                            this.$emit('delete', { commentId: this.comment.commentId });
                        });
                    }
                }
            };

            createApp({
                components: { 'comment-node': CommentNode },
                data() {
                    return {
                        bookId: null, loading: true,
                        book: {}, sentences: [], comments: [],
                        isLoggedIn: false, currentUserNickname: null, currentUserId: null, currentUserRole: null,
                        stompClient: null,
                        newSentence: '', newComment: '',
                        activeTypers: [], activeCommentTypers: [],
                        typingTimeout: null, commentTypingTimeout: null,
                        isTypingLock: false, links: {},
                        // Editing states
                        isEditingTitle: false, editTitleContent: '',
                        editingSentenceId: null, editSentenceContent: ''
                    }
                },
                computed: {
                    sortedSentences() { return this.sentences ? [...this.sentences].sort((a, b) => a.sequenceNo - b.sequenceNo) : []; },
                    isWriter() { return this.book && this.book.writerId && this.currentUserId && (this.book.writerId === this.currentUserId); },
                    isAdmin() { return this.currentUserRole === 'ADMIN' || this.currentUserRole === 'ROLE_ADMIN'; },
                    canEditBook() { return this.isWriter || this.isAdmin; },
                    // isTypingLock computed property was duplicated and incorrectly defined.
                    // The `activeTypers` array length already determines if someone else is typing.
                    // The `isTypingLock` data property is no longer needed as a separate state.
                    // The `isInputDisabled` computed property will use `this.activeTypers.length > 0` directly.
                    // isTypingLock() { return this.activeTypers.length > 0; }, // Removed this line
                    isInputDisabled() {
                        if (!this.isLoggedIn) return true;
                        if (this.book && this.book.status === 'COMPLETED') return true;
                        if (this.activeTypers.length > 0) return true; // Use activeTypers directly
                        if (this.currentUserId && this.book && this.book.lastWriterUserId === this.currentUserId) return true;
                        return false;
                    },
                    inputPlaceholder() {
                        if (this.book && this.book.status === 'COMPLETED') return "ì†Œì„¤ì´ ì™„ê²°ë˜ì—ˆìŠµë‹ˆë‹¤.";
                        if (this.currentUserId && this.book && this.book.lastWriterUserId === this.currentUserId) return "ì—°ì†ìœ¼ë¡œ ì‘ì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ë¶„ì´ ì´ì–´ì„œ ì¨ì£¼ì‹œê¸°ë¥¼ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”! â³";
                        if (this.activeTypers.length > 0) { const typer = this.activeTypers[0]; return `${typer}ë‹˜ì´ ì‘ì„± ì¤‘ì…ë‹ˆë‹¤... âœï¸`; }
                        return "ë‹¹ì‹ ì˜ ìƒìƒë ¥ì„ í¼ì³ë³´ì„¸ìš”... (ìµœëŒ€ 200ì)";
                    }
                },
                mounted() {
                    const bookId = window.location.pathname.split('/').pop();
                    this.bookId = bookId;
                    this.checkLogin().then(() => { this.fetchBookDetail(); this.fetchComments(); this.connectWebSocket(); });
                    const urlParams = new URLSearchParams(window.location.search);
                    if (urlParams.get('created') === 'true') { showToast('ì†Œì„¤ì´ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ‰', 'success'); history.replaceState({}, document.title, window.location.pathname); }
                    window.categoryMap = window.categoryMap || { 'THRILLER': 'ìŠ¤ë¦´ëŸ¬', 'ROMANCE': 'ë¡œë§¨ìŠ¤', 'FANTASY': 'íŒíƒ€ì§€', 'MYSTERY': 'ë¯¸ìŠ¤í„°ë¦¬' };
                },
                methods: {
                    async checkLogin() {
                        const token = localStorage.getItem('accessToken');
                        this.isLoggedIn = !!token;
                        if (this.isLoggedIn) {
                            try {
                                const response = await fetch('/api/members/me', { headers: { 'Authorization': 'Bearer ' + token } });
                                const res = await response.json();
                                if (res && res.data) {
                                    this.currentUserNickname = res.data.userNicknm;
                                    this.currentUserId = res.data.userId;
                                    this.currentUserRole = res.data.userRole; // Capture role
                                }
                            } catch (e) { console.error("Login check failed", e); }
                        }
                    },
                    getCategoryName(code) { return window.categoryMap?.[code] || code; },
                    fetchBookDetail() {
                        $.ajax({
                            url: '/api/books/' + this.bookId + '/view', method: 'GET',
                            success: (response) => {
                                this.book = response.data;
                                if (this.book._links) this.links = this.book._links;
                                this.sentences = this.book.sentences || [];
                                this.loading = false;
                            },
                            error: (xhr) => {
                                if (xhr.status === 401 || xhr.status === 403) {
                                    showToast('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.', 'warning');
                                    openModal('login-modal', true);
                                } else {
                                    showToast('ì†Œì„¤ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
                                }
                                this.loading = false;
                            }
                        });
                    },
                    fetchComments() {
                        const url = (this.links && this.links.comments) ? this.links.comments.href : ('/api/reactions/comments/' + this.bookId);
                        $.ajax({ url: url, method: 'GET', success: (response) => { this.comments = response.data; } });
                    },
                    connectWebSocket() {
                        const socket = new SockJS('/ws');
                        this.stompClient = Stomp.over(socket);
                        this.stompClient.debug = null;
                        this.stompClient.connect({}, (frame) => {
                            // Subscribe to book-specific topics
                            this.stompClient.subscribe('/topic/typing/' + this.bookId, (message) => { this.handleTypingStatus(JSON.parse(message.body)); });
                            this.stompClient.subscribe('/topic/comment-typing/' + this.bookId, (message) => { this.handleCommentTypingStatus(JSON.parse(message.body)); });
                            this.stompClient.subscribe('/topic/sentences/' + this.bookId, (message) => { this.handleNewSentence(JSON.parse(message.body)); });
                            this.stompClient.subscribe('/topic/books/' + this.bookId + '/votes', (message) => { this.handleVoteUpdate(JSON.parse(message.body)); });
                            this.stompClient.subscribe('/topic/comments/' + this.bookId, (message) => { this.handleNewComment(JSON.parse(message.body)); });
                        });
                    },
                    handleNewComment(comment) {
                        this.comments.unshift(comment);
                    },
                    handleNewSentence(event) {
                        this.sentences.push({
                            sentenceId: Date.now(), content: event.content, sequenceNo: event.sequenceNo,
                            writerNicknm: event.writerNickname, writerId: event.writerId, likeCount: 0, dislikeCount: 0
                        });
                        // Update lastWriterUserId to unlock input for others
                        if (this.book) {
                            this.book.lastWriterUserId = event.writerId;
                        }
                        this.$nextTick(() => { $('html, body').animate({ scrollTop: $(document).height() }, 500); });
                    },
                    submitSentence() {
                        if (!this.newSentence) { showToast('ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'warning'); return; }
                        const url = this.links['append-sentence'] ? this.links['append-sentence'].href : ('/api/books/' + this.bookId + '/sentences');
                        $.ajax({
                            url: url, method: 'POST', contentType: 'application/json', data: JSON.stringify({ content: this.newSentence }),
                            success: () => { showToast('ë¬¸ì¥ì´ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success'); this.newSentence = ''; this.fetchBookDetail(); },
                            error: (xhr) => { if (xhr.status === 401) return; showToast('ë“±ë¡ ì‹¤íŒ¨: ' + (xhr.responseJSON ? xhr.responseJSON.message : 'ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'), 'error'); }
                        });
                    },
                    submitComment() {
                        if (!this.newComment) return;
                        this.postComment(this.newComment, null, () => { this.newComment = ''; }, null);
                    },
                    submitReply(payload) { this.postComment(payload.content, payload.parentId, payload.callback, payload.link); },
                    postComment(content, parentId, callback, link) {
                        if (!this.isLoggedIn) { showToast('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.', 'error'); openModal('login-modal'); return; }
                        const url = link || '/api/reactions/comments';
                        $.ajax({
                            url: url, method: 'POST', contentType: 'application/json',
                            data: JSON.stringify({ bookId: this.bookId, content: content, parentId: parentId }),
                            success: () => { if (callback) callback(); this.fetchComments(); },
                            error: (xhr) => { if (xhr.status === 401) return; showToast('ëŒ“ê¸€ ë“±ë¡ ì‹¤íŒ¨: ' + (xhr.responseJSON ? xhr.responseJSON.message : 'ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'), 'error'); }
                        });
                    },
                    editComment(payload) { // { commentId, content, callback }
                        $.ajax({
                            url: '/api/reactions/comments/' + payload.commentId, method: 'PATCH', contentType: 'application/json',
                            data: JSON.stringify({ content: payload.content }),
                            success: () => { if (payload.callback) payload.callback(); this.fetchComments(); showToast('ëŒ“ê¸€ì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success'); },
                            error: (xhr) => { showToast('ìˆ˜ì • ì‹¤íŒ¨: ' + (xhr.responseJSON ? xhr.responseJSON.message : 'ì˜¤ë¥˜'), 'error'); }
                        });
                    },
                    deleteComment(payload) {
                        $.ajax({
                            url: '/api/reactions/comments/' + payload.commentId, method: 'DELETE',
                            success: () => { this.fetchComments(); showToast('ëŒ“ê¸€ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.', 'info'); },
                            error: (xhr) => { showToast('ì‚­ì œ ì‹¤íŒ¨: ' + (xhr.responseJSON ? xhr.responseJSON.message : 'ì˜¤ë¥˜'), 'error'); }
                        });
                    },
                    voteBook(voteType) {
                        if (!this.isLoggedIn) { showToast('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.', 'error'); openModal('login-modal'); return; }
                        const url = this.links['vote-book'] ? this.links['vote-book'].href : '/api/reactions/votes/books';
                        $.ajax({
                            url: url, method: 'POST', contentType: 'application/json', data: JSON.stringify({ bookId: parseInt(this.bookId), voteType: voteType }),
                            success: () => this.fetchBookDetail(), error: () => showToast('íˆ¬í‘œ ì‹¤íŒ¨', 'error')
                        });
                    },
                    voteSentence(sent, voteType) {
                        if (!this.isLoggedIn) { showToast('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.', 'error'); openModal('login-modal'); return; }
                        const url = (sent.links && sent.links.vote && sent.links.vote.href) ? sent.links.vote.href
                            : (sent._links && sent._links.vote ? sent._links.vote.href : ('/api/reactions/votes/sentences/' + sent.sentenceId));
                        $.ajax({
                            url: url, method: 'POST', contentType: 'application/json', data: JSON.stringify({ voteType: voteType }),
                            success: () => this.fetchBookDetail(), error: () => showToast('íˆ¬í‘œ ì‹¤íŒ¨', 'error')
                        });
                    },
                    completeBook() {
                        openConfirmModal('ì •ë§ë¡œ ì†Œì„¤ì„ ì™„ê²° ì§€ìœ¼ì‹œê² ìŠµë‹ˆê¹Œ?', () => {
                            $.ajax({
                                url: '/api/books/' + this.bookId + '/complete', method: 'POST',
                                success: () => { showToast('ì†Œì„¤ì´ ì™„ê²°ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success'); this.fetchBookDetail(); },
                                error: (xhr) => { showToast('ì™„ê²° ì²˜ë¦¬ ì‹¤íŒ¨', 'error'); }
                            });
                        });
                    },
                    handleVoteUpdate(update) {
                        if (update.targetType === 'BOOK' && update.targetId === parseInt(this.bookId)) {
                            this.book.likeCount = update.likeCount; this.book.dislikeCount = update.dislikeCount;
                        } else if (update.targetType === 'SENTENCE') {
                            const sentence = this.sentences.find(s => s.sentenceId === update.targetId);
                            if (sentence) { sentence.likeCount = update.likeCount; sentence.dislikeCount = update.dislikeCount; }
                        }
                    },
                    // Edit Book Title
                    startEditTitle() { this.editTitleContent = this.book.title; this.isEditingTitle = true; },
                    cancelEditTitle() { this.isEditingTitle = false; },
                    saveTitle() {
                        $.ajax({
                            url: '/api/books/' + this.bookId, method: 'PATCH', contentType: 'application/json',
                            data: JSON.stringify({ title: this.editTitleContent }),
                            success: () => { this.book.title = this.editTitleContent; this.isEditingTitle = false; showToast('ì œëª©ì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success'); },
                            error: (xhr) => showToast('ìˆ˜ì • ì‹¤íŒ¨', 'error')
                        });
                    },
                    // Edit Sentence
                    canEditSentence(sent) {
                        return (this.currentUserId && sent.writerId === this.currentUserId) || this.isAdmin;
                    },
                    startEditSentence(sent) {
                        // Restriction check
                        const last = this.sortedSentences[this.sortedSentences.length - 1];
                        if (sent.sentenceId !== last.sentenceId) {
                            showToast('ë§ˆì§€ë§‰ ë¬¸ì¥ë§Œ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.', 'error');
                            return;
                        }
                        this.editSentenceContent = sent.content;
                        this.editingSentenceId = sent.sentenceId;
                        // Lock: Send typing event
                        this.sendTyping(true);
                    },
                    cancelEditSentence() {
                        this.editingSentenceId = null;
                        this.sendTyping(false);
                    },
                    saveSentence(sent) {
                        $.ajax({
                            url: '/api/books/' + this.bookId + '/sentences/' + sent.sentenceId, method: 'PATCH', contentType: 'application/json',
                            data: JSON.stringify({ content: this.editSentenceContent }),
                            success: () => {
                                sent.content = this.editSentenceContent;
                                this.editingSentenceId = null;
                                showToast('ë¬¸ì¥ì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                                this.sendTyping(false);
                            },
                            error: (xhr) => {
                                showToast('ìˆ˜ì • ì‹¤íŒ¨', 'error');
                                this.sendTyping(false);
                            }
                        });
                    },
                    deleteBook() {
                        openConfirmModal('ì •ë§ë¡œ ì†Œì„¤ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', () => {
                            $.ajax({
                                url: '/api/books/' + this.bookId, method: 'DELETE',
                                success: () => { showToast('ì†Œì„¤ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.', 'info'); setTimeout(() => window.location.href = '/', 1000); },
                                error: (xhr) => showToast('ì‚­ì œ ì‹¤íŒ¨: ' + (xhr.responseJSON ? xhr.responseJSON.message : 'ì˜¤ë¥˜'), 'error')
                            });
                        });
                    },
                    deleteSentence(sent) {
                        // Restriction check
                        const last = this.sortedSentences[this.sortedSentences.length - 1];
                        if (sent.sentenceId !== last.sentenceId) {
                            showToast('ë§ˆì§€ë§‰ ë¬¸ì¥ë§Œ ì‚­ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.', 'error');
                            return;
                        }
                        openConfirmModal('ì •ë§ë¡œ ë¬¸ì¥ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?', () => {
                            $.ajax({
                                url: '/api/books/' + this.bookId + '/sentences/' + sent.sentenceId, method: 'DELETE',
                                success: () => {
                                    showToast('ë¬¸ì¥ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
                                    // Local update 
                                    const idx = this.sentences.findIndex(s => s.sentenceId === sent.sentenceId);
                                    if (idx !== -1) {
                                        this.sentences.splice(idx, 1);
                                        if (this.book) this.book.currentSequence--;
                                        // Update lastWriterUserId
                                        if (this.sentences.length > 0) {
                                            // The new last sentence defines the last writer
                                            const newLast = this.sentences[this.sentences.length - 1]; // sentences is unsorted in data but we can use helper or assume fetch logic
                                            // Better use sortedSentences logic or re-fetch.
                                            // But for UI feedback:
                                            this.book.lastWriterUserId = newLast.writerId;
                                        } else {
                                            this.book.lastWriterUserId = null;
                                        }
                                    }
                                },
                                error: (xhr) => showToast('ì‚­ì œ ì‹¤íŒ¨: ' + (xhr.responseJSON ? xhr.responseJSON.message : 'ì˜¤ë¥˜'), 'error')
                            });
                        });
                    }
                }
            }).mount('#app');
        </script>
    </th:block>

</body>

</html>