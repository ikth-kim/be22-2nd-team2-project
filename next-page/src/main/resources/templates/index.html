<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org" xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
    layout:decorate="~{layout}">

<head>
    <title>Next Page - í™ˆ</title>
</head>

<body>

    <div layout:fragment="content" id="app">
        <!-- Floating Atmosphere (Only on index page) -->
        <div class="shape shape-1"></div>
        <div class="shape shape-2"></div>

        <div class="text-center mb-4" style="padding: 60px 0;">
            <h1 class="hero-title floating text-glow">
                ìš°ë¦¬ê°€ í•¨ê»˜ ë§Œë“œëŠ” ì´ì•¼ê¸°
            </h1>
            <p style="font-size: 1.2rem; color: var(--text-muted); max-width: 600px; margin: 0 auto; line-height: 1.8;">
                ë‹¹ì‹ ì˜ í•œ ë¬¸ì¥ì´ ë² ìŠ¤íŠ¸ì…€ëŸ¬ì˜ ì‹œì‘ì´ ë©ë‹ˆë‹¤.<br>
                ì§€ê¸ˆ ë°”ë¡œ ë¦´ë ˆì´ ì†Œì„¤ì— ì°¸ì—¬í•´ë³´ì„¸ìš”.
            </p>
            <div class="mt-4" id="hero-cta">
                <div class="guest-only" style="display: flex; justify-content: center; gap: 15px;">
                    <button onclick="openModal('login-modal')" class="btn btn-outline"
                        style="font-size: 1.1rem; padding: 12px 30px;">ë¡œê·¸ì¸</button>
                    <button onclick="openModal('signup-modal')" class="btn btn-primary"
                        style="font-size: 1.1rem; padding: 12px 30px;">íšŒì›ê°€ì…</button>
                </div>
                <!-- Note: This user-only part is managed by server-side or auth token check. 
                     Since we are moving to Vue, we might want to check auth token for this display too 
                     or rely on server-side rendering for initial state if thymeleaf handles it. 
                     For now, I'll keep the static style check or add v-if based on token. -->
                <div class="user-only" style="display: none; justify-content: center;">
                    <a href="/books/new" class="btn btn-primary" style="font-size: 1.1rem; padding: 12px 30px;">ì´ì•¼ê¸°
                        ì‹œì‘í•˜ê¸°</a>
                </div>
            </div>
        </div>

        <!-- Filter & Search -->
        <div class="card"
            style="display: flex; gap: 15px; flex-wrap: wrap; align-items: center; z-index: 10; position: relative; margin-bottom: 30px;">
            <select v-model="filters.categoryId" class="form-control" style="width: auto;">
                <option value="">ì „ì²´ ì¹´í…Œê³ ë¦¬</option>
                <option v-for="cat in categories" :key="cat.categoryId" :value="cat.categoryId">{{ cat.categoryName }}
                </option>
            </select>
            <select v-model="filters.status" class="form-control" style="width: auto;">
                <option value="">ëª¨ë“  ìƒíƒœ</option>
                <option value="WRITING">ì—°ì¬ì¤‘</option>
                <option value="COMPLETED">ì™„ê²°</option>
            </select>
            <input type="text" v-model="filters.keyword" class="form-control" placeholder="ì œëª©/ì‘ê°€ ê²€ìƒ‰..." style="flex: 1;"
                @input="debouncedSearch">
        </div>

        <!-- Book Grid -->
        <div class="grid" id="book-list">
            <div v-for="book in books" :key="book.bookId" class="card" @click="goDetail(book.bookId)"
                style="cursor: pointer; animation: slideInFromBottom 0.5s ease-out;">
                <div class="book-cover-placeholder">
                    <span class="book-icon">{{ getIcon(book.categoryId) }}</span>
                </div>
                <div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                    <span class="badge" :class="book.status === 'WRITING' ? 'badge-writing' : 'badge-completed'">{{
                        book.status }}</span>
                    <span
                        style="font-size: 0.8rem; color: var(--text-muted); text-transform:uppercase; letter-spacing:1px;">{{
                        getCategoryName(book.categoryId) }}</span>
                </div>
                <h3
                    style="margin-bottom: 10px; font-size: 1.4rem; font-weight: 700; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                    {{ book.title }}</h3>
                <p style="font-size: 0.9rem; color: var(--text-muted); margin-bottom: 20px;">
                    <span style="color: var(--primary-color);">Make by.</span> {{ book.writerNicknm || 'ì‘ê°€ë‹˜' }}
                </p>
                <div
                    style="display: flex; justify-content: space-between; align-items: center; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 15px;">
                    <span style="font-size: 0.85rem; color: var(--text-muted);">
                        ğŸ‘¥ {{ book.participantCount || 1 }}ëª… ì°¸ì—¬
                    </span>
                    <span style="font-size: 0.85rem; color: var(--text-muted);">
                        ğŸ“ {{ book.currentSequence }} ë¬¸ì¥
                    </span>
                </div>
            </div>

            <!-- Loading Spinner / Sentinel -->
            <div id="sentinel" style="height: 20px; grid-column: 1/-1;">
                <div v-if="loading" class="text-center" style="padding: 20px; color: var(--text-muted);">
                    Loading...
                </div>
            </div>

            <div v-if="books.length === 0 && !loading" class="card"
                style="grid-column: 1/-1; padding: 60px 20px; text-align: center;">
                <div style="font-size: 4rem; margin-bottom: 20px;">ğŸ“š</div>
                <h3 style="color: var(--text-muted); margin-bottom: 10px;">ë“±ë¡ëœ ì†Œì„¤ì´ ì—†ìŠµë‹ˆë‹¤.</h3>
                <p style="color: var(--text-muted); font-size: 0.9rem;">ë‹¤ë¥¸ ê²€ìƒ‰ì–´ë¥¼ ì‹œë„í•˜ê±°ë‚˜ ìƒˆë¡œìš´ ì´ì•¼ê¸°ë¥¼ ì‹œì‘í•´ë³´ì„¸ìš”!</p>
            </div>
        </div>
    </div>

    <th:block layout:fragment="script">
        <script>
            const { createApp } = Vue;

            createApp({
                data() {
                    return {
                        books: [],
                        categories: [],
                        categoryMap: {},
                        filters: {
                            categoryId: '',
                            status: '',
                            keyword: ''
                        },
                        page: 0,
                        size: 20,
                        loading: false,
                        hasNext: true,
                        searchTimeout: null,
                        observer: null
                    }
                },
                mounted() {
                    this.fetchCategories();
                    this.loadBooks();
                    this.setupObserver();
                    this.checkAuth();
                },
                watch: {
                    'filters.categoryId': 'resetAndLoad',
                    'filters.status': 'resetAndLoad'
                },
                methods: {
                    checkAuth() {
                        if (localStorage.getItem('accessToken')) {
                            $('.user-only').show(); // Legacy support or just use v-show inside Vue
                            $('.user-only').css('display', 'flex'); // Flex for button container
                            $('.guest-only').hide();
                        } else {
                            $('.user-only').hide();
                            $('.guest-only').show();
                        }
                    },
                    fetchCategories() {
                        $.ajax({
                            url: '/api/categories',
                            method: 'GET',
                            success: (response) => {
                                this.categories = response.data;
                                this.categories.forEach(cat => {
                                    this.categoryMap[cat.categoryId] = cat.categoryName;
                                });
                            }
                        });
                    },
                    loadBooks(isAppend = false) {
                        if (this.loading || (!this.hasNext && isAppend)) return;
                        this.loading = true;

                        $.ajax({
                            url: '/api/books',
                            method: 'GET',
                            data: {
                                categoryId: this.filters.categoryId,
                                status: this.filters.status,
                                keyword: this.filters.keyword,
                                page: this.page,
                                size: this.size
                            },
                            success: (response) => {
                                const data = response.data;
                                if (isAppend) {
                                    this.books = [...this.books, ...data.content];
                                } else {
                                    this.books = data.content;
                                }
                                this.hasNext = !data.last;
                                if (this.hasNext) this.page++;
                                this.loading = false;
                            },
                            error: () => {
                                this.loading = false;
                            }
                        });
                    },
                    resetAndLoad() {
                        this.page = 0;
                        this.hasNext = true;
                        this.books = [];
                        this.loadBooks();
                    },
                    debouncedSearch() {
                        clearTimeout(this.searchTimeout);
                        this.searchTimeout = setTimeout(() => {
                            this.resetAndLoad();
                        }, 500);
                    },
                    setupObserver() {
                        this.observer = new IntersectionObserver((entries) => {
                            if (entries[0].isIntersecting) {
                                this.loadBooks(true);
                            }
                        }, { threshold: 0.1 });
                        const sentinel = document.getElementById('sentinel');
                        if (sentinel) this.observer.observe(sentinel);
                    },
                    goDetail(bookId) {
                        window.location.href = '/books/' + bookId;
                    },
                    getCategoryName(id) {
                        return this.categoryMap[id] || id || 'ë¯¸ë¶„ë¥˜';
                    },
                    getIcon(catId) {
                        const name = this.categoryMap[catId] || '';
                        if (catId === 'ROMANCE' || name.includes('ë¡œë§¨ìŠ¤')) return 'ğŸ’–';
                        if (catId === 'THRILLER' || name.includes('ìŠ¤ë¦´ëŸ¬')) return 'ğŸ”ª';
                        if (catId === 'FANTASY' || name.includes('íŒíƒ€ì§€')) return 'ğŸ°';
                        if (catId === 'SF' || name.includes('SF')) return 'ğŸ‘½';
                        if (catId === 'MYSTERY' || name.includes('ë¯¸ìŠ¤í„°ë¦¬')) return 'ğŸ•µï¸';
                        if (catId === 'DAILY' || name.includes('ì¼ìƒ')) return 'â˜•';
                        return 'ğŸ“–';
                    }
                }
            }).mount('#app');
        </script>
    </th:block>

</body>

</html>